// Copyright 2021 Google LLC
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree.

$assert DATATYPE in ["QB4_F16"]
#include <assert.h>
$if VARIANT == "LRINTF":
  #include <math.h>

#include <xnnpack/gemm.h>
#include <xnnpack/math.h>
#include <xnnpack/unaligned.h>
#include <fp16/fp16.h>


$DATATYPE_SPEC = {"QB4_F16": "qd8_f16_qb4w"}[DATATYPE]
$PARAMS_STRUCT = REQUANTIZATION.lower() + "_scalar" + ("_" + VARIANT.lower() if VARIANT else "")
$PARAMS_UNION = {"QB4_F16": "xnn_f16_qc4w_minmax_params"}[DATATYPE]
$SCALING_PARAMS = "xnn_qd8_quantization_params" if DATATYPE in ["QB4_F16"] else ""
$XINT8_T = "int8_t"
$MIN_F32 = "math_min_f32"
$MAX_F32 = "math_max_f32"
void xnn_${DATATYPE_SPEC}_gemm_minmax_ukernel_${MR}x${NR}__scalar(
    size_t mr,
    size_t nc,
    size_t kc,
    size_t bl,
    const ${XINT8_T}* __restrict__ a,
    size_t a_stride,
    const void* __restrict__ w,
    void* __restrict__ c,
    size_t cm_stride,
    size_t cn_stride,
    const union ${PARAMS_UNION} params[XNN_MIN_ELEMENTS(1)],
    const struct ${SCALING_PARAMS} quantization_params[XNN_MIN_ELEMENTS(1)])
{
  assert(mr != 0);
  assert(mr <= 1);
  assert(nc != 0);
  assert(kc != 0);

  const int8_t* a0 = a;
  uint16_t* c0 = (uint16_t*)c;
  size_t nc_block = 0;

  kc = round_up_po2(kc, 2);
  do {
    $for N in range(NR):
        const float vksum${N} = unaligned_indexed_load_f32(w, ${N});
    w = (const float*) w + ${NR};

    const int32_t vinput_zero_point0 = quantization_params[0].zero_point;

    $for N in range(NR):
        float vout0x${N} = (float) vinput_zero_point0 * vksum${N};

    size_t n_blocks = kc / bl;

    for (size_t nb=0; nb<n_blocks; ++nb){
      $for N in range(NR):
        int32_t vacc0x${N} = 0;

      for (size_t k=bl; k >= 2 * sizeof(uint8_t); k -= 2 * sizeof(uint8_t)) {
        const int32_t va0c0 = (int32_t) a0[0];
        const int32_t va0c1 = (int32_t) a0[1];
        a0 += 2;

        $for N in range(NR):
            const uint8_t vbi${N} = ((const uint8_t*) w)[${N}];
        w = (const uint8_t*) w + ${NR};

        $for N in range(NR):
            const int32_t vb${N}c0 = (int32_t) (int8_t) (vbi${N} << 4);
            const int32_t vb${N}c1 = (int32_t) (int8_t) (vbi${N} & 0xF0);

        $for N in range(NR):
            vacc0x${N} += va0c0 * vb${N}c0;
        $for N in range(NR):
            vacc0x${N} += va0c1 * vb${N}c1;
      }

      $for N in range(NR):
        float vf0x${N} = vacc0x${N};

      $for N in range(NR):
        const float vfilter_output_scale${N} = unaligned_indexed_load_f32(w, 0);
        w = (const float*) w + 1;
        vf0x${N} *= vfilter_output_scale${N};

      $for N in range(NR):
        vout0x${N} += vf0x${N};
    }

    $for N in range(NR):
        vout0x${N} /= 16;

    const float vinput_scale0 = quantization_params[0].inv_scale;
    $for N in range(NR):
        vout0x${N} *= vinput_scale0;

    $for N in range(NR):
        const float vbias${N} = unaligned_indexed_load_f32(w, ${N});
        vout0x${N} += vbias${N};
    w = (const float*) w + ${NR};

    const float voutput_min = fp16_ieee_to_fp32_value(params->fp16arith.min);
    $for N in range(NR):
        vout0x${N} = math_max_f32(vout0x${N}, voutput_min);

    const float voutput_max = fp16_ieee_to_fp32_value(params->fp16arith.max);
    $for N in range(NR):
        vout0x${N} = math_min_f32(vout0x${N}, voutput_max);

    if XNN_LIKELY(nc >= ${NR}) {
      $for N in range(NR):
        c0[${N}] = fp16_ieee_from_fp32_value(vout0x${N});

      a0 = (const int8_t*) ((uintptr_t) a0 - kc);

      c0 = (uint16_t*) ((uintptr_t) c0 + cn_stride);

      nc -= ${NR};
    } else {
      $for LOG2N in reversed(range(NR.bit_length() - 1)):
        if (nc & ${1 << LOG2N}) {
            $for N in range(1 << LOG2N):
                c0[${N}] = fp16_ieee_from_fp32_value(vout0x${N});
            $if LOG2N != 0:
                $for N in range(NR - (1 << LOG2N) - 1):
                    vout0x${N} = vout0x${N + (1 << LOG2N)};
            c0 += ${1 << LOG2N};
        }

      nc = 0;
    }
  } while (nc != 0);
}